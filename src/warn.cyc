/* Name resolution
   Copyright (C) 2003 Dan Grossman, AT&T
   This file is part of the Cyclone compiler.

   The Cyclone compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The Cyclone compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the Cyclone compiler; see the file COPYING. If not,
   write to the Free Software Foundation, Inc., 59 Temple Place -
   Suite 330, Boston, MA 02111-1307, USA. */

#include <position.h>
#include <string.h>
#include "absynpp.h"
#include "warn.h"
using List;
using Absyn;
using Absynpp;

namespace Warn;

static list_t<seg_t>       warning_segs = NULL;
static list_t<stringptr_t> warning_msgs = NULL;

datatype Warg {
  String(string_t);
  Exp(exp_t);
  Typ(type_t);
  Qvar(qvar_t);
};

// we batch warnings because we have to parse the file to determine
// line and column information.
void vwarn(seg_t loc, string_t fmt, parg_t ? ap) {
  string_t msg = vrprintf(Core::heap_region,fmt,ap);
  warning_segs = new List(loc,      warning_segs);
  warning_msgs = new List(new msg, warning_msgs);
}

void warn(seg_t loc, string_t fmt, ... inject parg_t ap)
  __attribute__((format(printf,2,3))) {
  vwarn(loc, fmt, ap);
}
void flush_warnings() {
  if(warning_segs == NULL)
    return;
  fprintf(stderr,"***Warnings***\n");
  let seg_strs = Position::strings_of_segments(warning_segs);
  warning_segs = NULL;
  warning_msgs = imp_rev(warning_msgs);
  while(warning_msgs != NULL) {
    fprintf(stderr,"%s: %s\n", *(seg_strs->hd), *(warning_msgs->hd));
    seg_strs     = seg_strs->tl;
    warning_msgs = warning_msgs->tl;
  }
  fprintf(stderr,"**************\n");
  fflush(stderr);
}

void verr(seg_t loc, string_t fmt, parg_t ? ap) {
 Position::post_error(Position::mk_err(loc,vrprintf(Core::heap_region,fmt,ap)));
}

void err(seg_t loc, string_t fmt, ... inject parg_t ap)
  __attribute__((format(printf,2,3))) {
  verr(loc, fmt, ap);
}

`a vimpos(string_t fmt, parg_t ? ap) __attribute__((noreturn)) {
  string_t msg = vrprintf(Core::heap_region,fmt,ap);
  if (!Position::error_p()) {
    fprintf(stderr,"Compiler Error: %s\n",msg);
    fflush(stderr);
  }
  throw new Core::Impossible(msg);  
}

`a impos(string_t fmt, ... inject parg_t ap)
  __attribute__((format(printf,1,2), noreturn)) {
  vimpos(fmt, ap);
}

`a vimpos_loc(seg_t loc, string_t fmt, parg_t ? ap) __attribute__((noreturn)) {
  if (!Position::error_p()) {
    fprintf(stderr,"Compiler Error: \n");
    verr(loc,fmt,ap);
  }
  throw new Core::Impossible("Compiler Error");  
}

`a impos_loc(seg_t loc, string_t fmt, ... inject parg_t ap)
  __attribute__((format(printf,2,3), noreturn)) {
  vimpos_loc(loc, fmt, ap);
}

static string_t args2string(warg_t ? args) {
  list_t<stringptr_t> lst = NULL;
  for(int i=numelts(args)-1; i >= 0; --i) {
    string_t s;
    switch(args[i]) {
    case &String(s2): s = s2; break;
    case &Exp(e):     s = exp2string(e); break;
    case &Typ(t):     s = typ2string(t); break;
    case &Qvar(qv):   s = qvar2string(qv); break;
    }
    lst = new List(new s,lst); 
  }
  return strconcat_l(lst);
}
void verr2(seg_t loc, warg_t ? args) {
  Position::post_error(Position::mk_err(loc,args2string(args)));
}
void err2(seg_t loc, ... inject warg_t args) {
  verr2(loc,args);
}
void vwarn2(seg_t loc, warg_t ? args) {
  string_t msg = args2string(args);
  warning_segs = new List(loc,     warning_segs);
  warning_msgs = new List(new msg, warning_msgs);
}
void warn2(seg_t loc, ... inject warg_t args) {
  vwarn2(loc,args);
}
